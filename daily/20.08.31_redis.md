# redis

redis 是一个开源的基于内存的键值对数据存储系统，支持的数据类型有：

- string：支持字符串；数值，数值支持整型、浮点型的运算；bitmap，可以用于大量数据下活跃用户的统计
- hash：支持数值运算
- list：可以通过不同的命令组合实现队列、栈数据结构，list 是插入顺序有序的
- set：无序、去重的集合，支持集合的交集、并集、差集，以及随机事件，随机事件可以根据数值控制返回的数据是否重复
- sorted_set：按 score 排序的有序去重集合，支持集合的聚合，可以设置权重，以及聚合的方式，redis 内部通过跳跃表的方式，实现 sorted_set

redis 是二进制安全的，客户端传递的数据直接入库，不关心编码。redis 可以用作缓存、数据库、消息中间件。redis 还内置支持 LUA 脚本、副本、事务、不同级别的磁盘持久化（RDB、AOF)，并通过哨兵、自动分区提供高可用性。

## redis 高效的原因

- 纯内存操作
- 基于非阻塞 I/O 多路复用机制管理连接
- 基于 C 语言开发
- redis 中有一部分组合命令，以及管道可以减少客户端和服务端通信次数

## redis 缓存 vs 数据库

- 缓存的一般是热点数据、全量数据一般会在数据库中保存
- 缓存的数据一般可以容忍数据丢失，数据库不行
- 作为缓存，当内存不够用时，允许通过一定的策略删除一部分缓存数据

## redis 持久化

### RDB

- 能够在指定的时间间隔对数据库进行快照存储。
- 体积小，恢复快，易于传输；
- 有可能会丢数据，rdb 需要经常 fork 子进程保存数据到硬盘，当数据集比较大的时候，fork 会耗时比较长，可能会导致 redis 在一些毫秒级内不能响应客户端的请求
- RDB 的原理是，主进程创建一个子进程，通过内存共享，共享数据，通过写时复制，主进程可以继续对数据操作，子进程可以将数据写入到 RDB 文件。

AOF：

- 只能进行追加的日志文件，体积比较大
- redis 可以在 AOF 文件体积过大时，自动地在后台对 AOF 进行重写，重写完成后，才会切换到新的 AOF 文件，并对新的 AOF 文件进行追加
- 默认的策略是每秒写入一次 AOF ，一旦出现故障，最多丢失 1 秒的数据
- AOF 文件有序的保存了对数据库执行的所有写入操作，可读，容易分析
- 效率相比 RDB 要低

AOF 同步到磁盘的方式：

- 每次有新命令就执行 fsync
- 每秒 fsync 一次(默认)
- 从不 fsync

## redis 高可用

单点存在的问题：

- 单点故障问题
- 服务能力有限
- 容量有限

高可用：

- 副本机制，可以解决单点故障问题，但是不能解决容量有限的问题

哨兵，用于监视 redis 的主从复制，如果主节点故障，可以自动实现故障转移。哨兵的配置文件中，需要设置哨兵的个数，只有满足个数条件后，才会判定主节点失效，失效后，会投票选出一个哨兵，执行故障转移。哨兵是通过 redis 的发布订阅功能，感知其他哨兵以及 redis 副本节点的存在。

- 解决服务能力有限和容量有限问题，可以通过代理的方式以及 redis 提供的 redis 集群方式

## redis 分布式锁

- 通过 set key value 的方式获取锁，创建成功，代表获取到锁
- 通过删除 key 释放锁

问题：

- 如果获取锁的进程挂掉了，会导致死锁，可以通过设置一个超时时间解决
- 上面解决了死锁的问题，又引入了新问题，锁未使用完毕，key 就超时被释放
- 可以考虑启动一个线程，在锁超时之前，更新一下超时时间，增加了复杂度

redission 提供了具有分布式特性的常用工具类。
