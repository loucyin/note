# 一致性 hash 算法

## 什么是一致性 hash 算法

一致性 hash 算法将 hash 值空间映射成一个虚拟圆环，按顺时针组织 ，0-2<sup>32</sup>-1 在 0 上重合。

### 原理

- 首先，对存储节点计算 hash 值，分配到环上；
- 对数据进行 hash 运算，按顺时针方向，将其映射到离其最近的节点上去；

### 增加、删除节点

- 当存储节点故障离线时，受影响的仅仅为环上故障节点逆时针方向到下一个节点之间的数据对象；
- 增加节点时，受影响的也仅仅是新增节点逆时针遍历到上个节点之间的数据对象；

### 优点

- 可扩展性，保证了增加减少节点时，节省了数据移动的开销；
- 更好的适应数据的快速增长，当数据不断增长时，部分虚拟节点中可能包含很多数据，造成数据分布不均衡，可以将包含数据多的节点分裂，不需要对全部数据进行重新 hash 和划分。

一致性 hash 算法是基于 hash 算法的基础上提出的，一致性 hash 算法提出了在动态变化的环境中， 判断 hash 算法好坏的四个定义：

- 平衡性：hash 结果尽可能平衡分布
- 单调性：新加或者删除节点，不影响系统正常运行
- 分散性：数据应该分散的存放在各个节点m

### 虚拟节点

当服务器少的时候，会出现 hash 环偏斜的情况，可以通过把物理节点的虚拟成多个节点的方法进行平衡。

## 协程

- 进程、线程是操作系统级的
- 协程是语言层级的
- 协程框架一般设计成 1：N 模式，1 个线程对应 N 个协程
- 协程适用于 IO 密集型的场景

优点：

- 协程更轻量，创建成本低，资源消耗少
- 减少同步加锁，可以提高性能
- 相比线程，协程的切换开销少

## 零拷贝

BIO读取文件使用 socket 发送出去的 Linux  IO 流程：

磁盘 -> 内核缓冲区 -> 用户缓冲区 -> 内核缓冲区 -> Socket

这里存在 4 次 copy。

- DMA 完成磁盘到内核的拷贝
- CPU 完成内核到用户缓冲区的拷贝
- CPU 把用户缓冲区的数据发送到待发送的内核缓冲区
- DMA 完成发送缓冲区数据到 Socket 的拷贝

### Linux 常见的零拷贝

1. mmap 内存映射

可以把应用程序缓冲区和内核缓冲区进行映射，这样只需要 3 次拷贝，2 次 DMA ，1 次 CPU

2. sendfile

调用 sendfile() 时，DMA 将数据复制到内核缓冲区，然后将内核缓冲区的数据复制到 socket 缓冲区，复制完毕后 sendfile() 返回。

同样需要 3 次拷贝，2 次 DMA ，1 次 CPU，性能优于 mmap ，因为 sendfile() 在内核和应用程序之间的上下文切换要少。

3. sendfile with DMA Scatter/Gather Copy

sendfile 增强版，需要 DMA 支持，只需要 2 次 DMA 

4. splice

数据从磁盘读取到内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据 buffer，而不需要拷贝到用户空间。

只需要 2 次 DMA 。
