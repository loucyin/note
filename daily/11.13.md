# jvm 运行时数据区

jvm 运行时数据区包括：

- 程序计数器（Program Counter Register）
- 虚拟机栈（VM Stack）
- 本地方法栈（Native Method Stack）
- 方法区（Method Area）
- 堆（Heap）

## 特性

### 程序计数器

- 没有 OutOfMemoryError
- 每个线程需要一个独立的程序计数器，属于“线程私有” 内存
- 如果执行 Native Method 这个计数器值为空

### 虚拟机栈

- 线程私有
- 描述 Java 方法执行的内存模型
- 每个方法从调用到执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程
- 局部变量表属于虚拟机栈，存放编译期已知的各种基本数据类型，对象引用和 returnAdrress 类型
- 规定了两种异常：OutOfMemoryError，StackOverFlow

### 本地方法栈

- 本地方法栈为虚拟机调用 Native 方法服务
- 规定了两种异常：OutOfMemoryError，StackOverFlow

### Java 堆

- Java 堆被所有线程共享
- 所有对象以及数组都要在堆上分配
- 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出 OutOfMemoryError

### 方法区

- 线程共享
- 用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 运行时常量池（Run-Time Constant Pool）是方法区的一部分
- 方法区在逻辑上是堆的一部分

运行时常量池：

- 存放编译器生成的各种字面量和符号引用，这些内容在类加载后进入常量池中存放
- 运行期间也可能将新的常量放入池中，如 String 的 intern() 方法

### 直接内存

- 不是 JVM 规范中定义的内存区域，非虚拟机运行时数据区的一部分
- 直接内存的分配不受 JVM 堆大小限制
- NIO 中使用 Native 函数库分配堆外内存，避免了在 Java 堆和 Native 堆中来回复制数据

## 其他

可达性分析算法中，可以作为 GCRoot 的对象：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象

关于永久代：

- 永久代是 HotSpot JVM 1.8 之前的概念
- 通过`-XX:MaxPermSize` 来设定永久代最大可分配的内存空间，32 位默认大小 64 M（64 位，85M）
- 永久代垃圾收集和老年代捆绑在一起
- JVM 加载的类的信息容量超出 MaxPermSize 就会 OOM
- HotSpot JVM 1.8 之后，使用 MetaSpace 替换了永久代
- 元空间并不在虚拟机中，而是使用本地内存，默认情况下，元空间的大小仅受本地内存限制，但可以通过参数来指定元空间的大小

为什么替换掉永久代：

- 永久代的大小不容易指定，太小容易永久代溢出，太大容易老年代溢出
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
- Oracle 可能会将HotSpot 与 JRockit 合二为一
