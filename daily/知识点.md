# 知识点

## MySQL

基本架构：

- 连接器 ： 管理连接 权限验证
- 查询缓存 分析器 ： 词法分析 语法分析
- 优化器 ：执行计划 索引选择
- 执行器 ：操作引擎 获取结果
- 存储引擎 ：存储数据 提供读写接口

备注：不推荐使用查询缓存，因为只要更新表，查询缓存就会清空，缓存对更新数据的命中率比较低

auto_inc 锁模式：

- 0 ：传统模式，所有的 insert-like 都会锁表
- 1 ：连续模式，所有的 bulk insert 会锁表，simple insert 使用轻量级锁，但是会等待表锁
- 2 ：交替模式，不会锁表，性能高，可以同时执行多个语句，但是对于基于语句的主从复制以及从bin log 中恢复数据不安全。

binlog 的三种模式：

- statement-based
- row-based
- mixed

MySQL 8.0 默认是 mixed , 5.7 默认的是 row-based。

### MySQL 优化

### MySQL 高可用方案

## 网络

OSI 7 层模型：

- 物理层
- 数据链路层 ： mac
- 网络层: IP ICMP IGMP
- 传输层: TCP UDP
- 会话层: 建立管理中止对话
- 表示层: JPEG
- 应用层: HTTP

tcp/ip 模型：

- 应用层
- 传输层
- 网际互联层
- 网络接入层

tcp 可靠性保证：

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制

  tcp 会把自身缓冲区的剩余大小放到 16 位窗口大小中。接收缓冲区满后，发送方，停止发送数据，定时进行窗口探测，直到接收缓冲区有空间，继续发送数据。流量控制是端到端的控制。

- 拥塞控制

  解决网络拥堵的问题，一般是慢启动策略。发送窗口会取拥塞窗口和接收窗口最小值，确定发送的数据量。拥塞窗口由发送端的算法控制，一般通过丢包进行感知。

  Linux 内核 4.9 中增加了 BBR 算法，不再使用丢包作为拥塞的信号，也不使用“加性增，乘性减”来维护窗口大小，通过估计极大带宽和极小延迟的乘积作为发送窗口大小。优点适合高带宽高延时的网络链路，可以充分利用带宽。

## io 模型

同步：应用进程主动向内核读取状态
异步：应用进程向内核注册，内核执行完成后，内核通知应用进程
阻塞：应用进程执行内核写入或者读取操作时，直到执行完成，才会返回应用空间
非阻塞：执行操作后，会立即返回

阻塞的原理：

- 操作系统为了支持多任务，把进程分为运行和等待等几种状态
- 当进程 A 创建 socket 语句时，操作系统会创建一个由文件系统管理的 socket 对象，这个对象包括发送缓冲区、接收缓冲区、等待队列等成员；
- 当进程 A 从 socket 读取数据时，进程 A 会被移动到 socket 的等待队列中，不在占用 cpu 资源
- socket 接收到数据后，操作系统将等待队列中的进程重新放回到工作队列

零拷贝：减少数据在内核缓冲区和应用缓冲区的拷贝次数为 0 ，mmap sendfile。

select poll : 可以通过一次系统调用，查询多路的状态，减少上下文的切换，但是查询时，要把在内核和用户缓冲区中复制文件描述符，select 可以打开的文件描述符受限可以通过 ulimit -n 查看，poll 的没有限制。内核需要遍历文件描述符，并把进程加入等待队列，进程唤醒后，需要遍历文件描述符，查看哪些有收到数据。

epoll : epoll_create epoll_ctl epoll_wait ，调用 epoll_create 后，内核会开辟空间，用于放置 socket ,当调用 epoll_ctl 添加 socket 时，内核会在缓冲区中创建一个红黑树保存 socket，以及一个就绪链表，存储就绪的事件,调用 epoll_wait 时，如果链表中有数据就会直接返回，没有数据返回 0 。epoll_wait 中会清空就绪链表，并检测链表中的 socket 如果是 lt 模式，并且有未处理的事件，再把数据放回清空的链表中。

epoll 的两种模式 LT (Level Triggered) 水平触发 ET (Edge Triggered) 边缘触发，LT 模式下只要一个句柄有数据没有处理完，以后每次调用 epoll_wait 都会返回句柄，ET 模式下只在第一次返回句柄。

## redis

redis 是一个开源的，内存中的数据结构存储系统，可以用作数据库，缓存和消息中间件。支持多种数据结构：字符串（string）、散列（hash）、列表（list)、集合(set)、有序集合(sorted set)，支持范围查询，bitmaps，hyperloglogs 和地理空间索引半径查询。Redis 内置了复制（replication),LUA 脚本，LRU驱动事件（LRU eviction），事务(transactions)和不同级别的磁盘持久化，并通过 Redis 哨兵（Sentinel）和自动分区(Cluster) 提供高可用性。

## 其他

- SPI service provider interface ，JDK 内置的服务发现机制。

## spring boot

### 启动流程

- 入口 SpringApplication.run ,会新建 SpringApplication 对象，并调用 run 方法

创建对象：

- 创建 SpringApplication 对象时，通过 getFactoryInstance 方法获取 ApplicationContextInitializer ApplicationListener
- getFactoryInstance 方法会加载 META-INF/spring.factories 下所有的 spring.factories 文件，并解析类名，生成对象

run 方法：

- 启动一个 StopWatch
- 获取 getFactoryInstance 生成 SpringApplicationRunListeners 对象，并执行对象的 starting 方法，通知所有的 SpringApplicationRunListener
- 创建 application context
- 通过 getFactoryInstance 获取 SpringBootExceptionReporter 对象集合
- prepare context 调用 SpringApplicationRunListeners contextLoaded 方法 以及 ApplicationContextInitializer initialize 方法
- refresh context
- 调用 SpringApplicationRunListeners started 方法
- 调用 callRunners，会通过 context 加载所有 ApplicationRunner 和 CommandLineRunner 并传入参数调用 run 方法

#### SpringApplicationRunListeners

listener 列表内只有一个 EventPublishingRunListener 对象

```properties
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener
```

EventPublishingRunListener 会获取 application 中的 listener 对象列表，并注册到 SimpleApplicationEventMulticaster 里面。

- context 为初始化完成之前，通过 SimpleApplicationEventMulticaster.multicastEvent 广播事件，包括 starting envPrepared contextPrepared contextLoaded
- contextLoaded 时，会把 listener 注册到 context 中
- 后续的事件通知通过 context.publishEvent 实现，

### spring boot 是如何集成 web 容器的

- spring application type SERVLET 的应用会创建 AnnotationConfigServletWebServerApplicationContext context

  - AnnotationConfigServletWebServerApplicationContext 继承与 ServletWebServerApplicationContext

- 在 ServletWebServerApplicationContext 的 onRefresh 方法中会 createWebServer，通过 ServletWebServerFactory 创建 webServer
- ServletWebServerFactory 在 EmbeddedWebServerFactoryCustomizerAutoConfiguration 中提供
- finishRefresh 的时候会 startWebServer，并发布事件 ServletWebServerInitializedEvent

spring boot 内支持 netty jetty tomcat undertow 四种 web 容器。

### DispatcherServlet
